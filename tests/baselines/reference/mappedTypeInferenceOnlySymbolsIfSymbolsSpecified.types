=== tests/cases/compiler/mappedTypeInferenceOnlySymbolsIfSymbolsSpecified.ts ===
const directive = Symbol('directive');
>directive : unique symbol
>Symbol('directive') : unique symbol
>Symbol : SymbolConstructor
>'directive' : "directive"

declare function foo<TArg, TRet, TDir>(options:
>foo : <TArg, TRet, TDir>(options: { [x: string]: (arg: TArg) => TRet; } & { [directive]?: TDir; }) => [TArg, TRet, TDir]
>options : { [x: string]: (arg: TArg) => TRet; } & { [directive]?: TDir; }

    {[x in string]: (arg: TArg) => TRet}
>arg : TArg

    & {[directive]?: TDir}
>[directive] : TDir
>directive : unique symbol

): [TArg, TRet, TDir];


let case1 = foo({
>case1 : [number, number, (x: string) => "str"]
>foo({    [directive]: (x: string) => 'str',    addOne: (x: number) => x + 1,    double: (x: number) => x + x,}) : [number, number, (x: string) => "str"]
>foo : <TArg, TRet, TDir>(options: { [x: string]: (arg: TArg) => TRet; } & { [directive]?: TDir; }) => [TArg, TRet, TDir]
>{    [directive]: (x: string) => 'str',    addOne: (x: number) => x + 1,    double: (x: number) => x + x,} : { [directive]: (x: string) => "str"; addOne: (x: number) => number; double: (x: number) => number; }

    [directive]: (x: string) => 'str',
>[directive] : (x: string) => "str"
>directive : unique symbol
>(x: string) => 'str' : (x: string) => "str"
>x : string
>'str' : "str"

    addOne: (x: number) => x + 1,
>addOne : (x: number) => number
>(x: number) => x + 1 : (x: number) => number
>x : number
>x + 1 : number
>x : number
>1 : 1

    double: (x: number) => x + x,
>double : (x: number) => number
>(x: number) => x + x : (x: number) => number
>x : number
>x + x : number
>x : number
>x : number

}); // [number, number, string => string]

let case2 = foo({
>case2 : [number, number, (x: string) => "str"]
>foo({    addOne: (x: number) => x + 1,    double: (x: number) => x + x,    [directive]: (x: string) => 'str',}) : [number, number, (x: string) => "str"]
>foo : <TArg, TRet, TDir>(options: { [x: string]: (arg: TArg) => TRet; } & { [directive]?: TDir; }) => [TArg, TRet, TDir]
>{    addOne: (x: number) => x + 1,    double: (x: number) => x + x,    [directive]: (x: string) => 'str',} : { addOne: (x: number) => number; double: (x: number) => number; [directive]: (x: string) => "str"; }

    addOne: (x: number) => x + 1,
>addOne : (x: number) => number
>(x: number) => x + 1 : (x: number) => number
>x : number
>x + 1 : number
>x : number
>1 : 1

    double: (x: number) => x + x,
>double : (x: number) => number
>(x: number) => x + x : (x: number) => number
>x : number
>x + x : number
>x : number
>x : number

    [directive]: (x: string) => 'str',
>[directive] : (x: string) => "str"
>directive : unique symbol
>(x: string) => 'str' : (x: string) => "str"
>x : string
>'str' : "str"

}); // [number, number, string => string]

let case3 = foo({
>case3 : [number, number, string]
>foo({    [directive]: 'str',    addOne: (x: number) => x + 1,    double: (x: number) => x + x,}) : [number, number, string]
>foo : <TArg, TRet, TDir>(options: { [x: string]: (arg: TArg) => TRet; } & { [directive]?: TDir; }) => [TArg, TRet, TDir]
>{    [directive]: 'str',    addOne: (x: number) => x + 1,    double: (x: number) => x + x,} : { [directive]: string; addOne: (x: number) => number; double: (x: number) => number; }

    [directive]: 'str',
>[directive] : string
>directive : unique symbol
>'str' : "str"

    addOne: (x: number) => x + 1,
>addOne : (x: number) => number
>(x: number) => x + 1 : (x: number) => number
>x : number
>x + 1 : number
>x : number
>1 : 1

    double: (x: number) => x + x,
>double : (x: number) => number
>(x: number) => x + x : (x: number) => number
>x : number
>x + x : number
>x : number
>x : number

}); // [number, number, string]

const strdirective = "directive";
>strdirective : "directive"
>"directive" : "directive"

declare function bar<TArg, TRet, TDir>(options:
>bar : <TArg, TRet, TDir>(options: { [x: symbol]: (arg: TArg) => TRet; } & { directive?: TDir; }) => [TArg, TRet, TDir]
>options : { [x: symbol]: (arg: TArg) => TRet; } & { directive?: TDir; }

    {[x in symbol]: (arg: TArg) => TRet}
>arg : TArg

    & {[strdirective]?: TDir}
>[strdirective] : TDir
>strdirective : "directive"

): [TArg, TRet, TDir];

const s1 = Symbol("s1");
>s1 : unique symbol
>Symbol("s1") : unique symbol
>Symbol : SymbolConstructor
>"s1" : "s1"

const s2 = Symbol("s2");
>s2 : unique symbol
>Symbol("s2") : unique symbol
>Symbol : SymbolConstructor
>"s2" : "s2"

let case4 = bar({
>case4 : [number, number, (x: string) => "str"]
>bar({    [strdirective]: (x: string) => 'str',    [s1]: (x: number) => x + 1,    [s2]: (x: number) => x + x,}) : [number, number, (x: string) => "str"]
>bar : <TArg, TRet, TDir>(options: { [x: symbol]: (arg: TArg) => TRet; } & { directive?: TDir; }) => [TArg, TRet, TDir]
>{    [strdirective]: (x: string) => 'str',    [s1]: (x: number) => x + 1,    [s2]: (x: number) => x + x,} : { directive: (x: string) => "str"; [s1]: (x: number) => number; [s2]: (x: number) => number; }

    [strdirective]: (x: string) => 'str',
>[strdirective] : (x: string) => "str"
>strdirective : "directive"
>(x: string) => 'str' : (x: string) => "str"
>x : string
>'str' : "str"

    [s1]: (x: number) => x + 1,
>[s1] : (x: number) => number
>s1 : unique symbol
>(x: number) => x + 1 : (x: number) => number
>x : number
>x + 1 : number
>x : number
>1 : 1

    [s2]: (x: number) => x + x,
>[s2] : (x: number) => number
>s2 : unique symbol
>(x: number) => x + x : (x: number) => number
>x : number
>x + x : number
>x : number
>x : number

}); // [number, number, string => string]

let case5 = bar({
>case5 : [number, number, (x: string) => "str"]
>bar({    [s1]: (x: number) => x + 1,    [s2]: (x: number) => x + x,    [strdirective]: (x: string) => 'str',}) : [number, number, (x: string) => "str"]
>bar : <TArg, TRet, TDir>(options: { [x: symbol]: (arg: TArg) => TRet; } & { directive?: TDir; }) => [TArg, TRet, TDir]
>{    [s1]: (x: number) => x + 1,    [s2]: (x: number) => x + x,    [strdirective]: (x: string) => 'str',} : { [s1]: (x: number) => number; [s2]: (x: number) => number; directive: (x: string) => "str"; }

    [s1]: (x: number) => x + 1,
>[s1] : (x: number) => number
>s1 : unique symbol
>(x: number) => x + 1 : (x: number) => number
>x : number
>x + 1 : number
>x : number
>1 : 1

    [s2]: (x: number) => x + x,
>[s2] : (x: number) => number
>s2 : unique symbol
>(x: number) => x + x : (x: number) => number
>x : number
>x + x : number
>x : number
>x : number

    [strdirective]: (x: string) => 'str',
>[strdirective] : (x: string) => "str"
>strdirective : "directive"
>(x: string) => 'str' : (x: string) => "str"
>x : string
>'str' : "str"

}); // [number, number, string => string]

let case6 = bar({
>case6 : [number, number, string]
>bar({    [strdirective]: 'str',    [s1]: (x: number) => x + 1,    [s2]: (x: number) => x + x,}) : [number, number, string]
>bar : <TArg, TRet, TDir>(options: { [x: symbol]: (arg: TArg) => TRet; } & { directive?: TDir; }) => [TArg, TRet, TDir]
>{    [strdirective]: 'str',    [s1]: (x: number) => x + 1,    [s2]: (x: number) => x + x,} : { directive: string; [s1]: (x: number) => number; [s2]: (x: number) => number; }

    [strdirective]: 'str',
>[strdirective] : string
>strdirective : "directive"
>'str' : "str"

    [s1]: (x: number) => x + 1,
>[s1] : (x: number) => number
>s1 : unique symbol
>(x: number) => x + 1 : (x: number) => number
>x : number
>x + 1 : number
>x : number
>1 : 1

    [s2]: (x: number) => x + x,
>[s2] : (x: number) => number
>s2 : unique symbol
>(x: number) => x + x : (x: number) => number
>x : number
>x + x : number
>x : number
>x : number

}); // [number, number, string]

